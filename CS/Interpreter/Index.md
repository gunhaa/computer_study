# 인터프리터와 컴파일러

## 언어(컴파일러)의 구성요소

> `var average = (min + max)/2;`의 구성을 처음부터 끝까지 분석해보면..

- 컴파일러의 구조는 아래 단계로 나뉜다
  - 프론트엔드 (Front-end): 소스 코드(C++, Java 등)를 읽어서 문법 검사를 하고 초기 IR(중간 표현, Intermediate Representation)을 만들어낸다
  - 미들엔드 (Middle-end): 프론트엔드가 넘겨준 IR을 분석하고 최적화(Optimization)한다, 코드를 더 빠르게, 혹은 더 작게 만든다. (예: 안 쓰는 변수 삭제, 반복문 계산 줄이기)
  - 백엔드 (Back-end): 최적화된 IR을 실제 CPU가 이해하는 기계어(Machine Code)나 어셈블리어로 바꾼다. (x86, ARM 등)
- 컴파일러는 각 단계의 작업이 다음 단계를 구현하기 쉽게 만드는 방향으로 사용자 코드를 나타내는, 일종의 데이터를 구성하는 파이프라인 이다
- 프론트엔드는 프로그램이 작성된 소스언어에 따라 달라지는 반면, 백엔드는 프로그램이 최종 실행될 타깃 아키텍처에 깊이 연관되어 있다

### 언어(컴파일러)의 프론트엔드

> 코드를 읽고 문법이 맞는지, 타입이 맞는지 분석하는 단계

1. 스캐닝(scanning) 혹은 lexing(lexical analysis, 어휘 분석)
  - 스캐너(or lexer)는 문자(character)의 선형 스트림을 받아 '단어'에 가까운 chunk들로 묶는다
  - 프로그래밍 언어에서는 이런 단어를 token이라고 한다
  - 어떤 토큰은 `나,` 처럼 단일 문자 구성된 경우도 있고, 숫자(123), 문자열 리터럴("hi"), 식별자(identifer, min)처럼 여러 문자로 이루어진 토큰도 있다
  - 소스 파일에는 아무 의미 없는 문자도 있다. 공백 문자(whitespace)는 대개 중요하지 않다
  - 주석은 정의에 따라 무시된다
  - 스캐너는 이런 토큰을 버리고 의미 있는 토큰으로 정리한다

2. 파싱(parsing, 구문 분석)
  - 구문에 문법을 모아 더 큰 표현식과 문장을 구성하는 능력이다
  - 파서는 flat한 일련의 token을 받아 문법 특유의 중첩된 성질을 반영하는 트리 구조로 만든다
    - 이 트리는 원시 구문 구조에 얼마나 가까운지에 따라 파스 트리(parse tree) 또는 추상 구문 트리(AST, Abstract Syntax Tree)라는 상이한 두 가지 이름으로 불린다
  - AI 분야와 큰 연관이 있으며, 요즘 프로그래밍 언어의 파싱 기법은 인간과 대화가 가능한 컴퓨터를 연구하던 AI과학자들이 인간의 언어를 파싱하려고 만든 것이다
    - 인간의 언어는 엄격히 정해진 문법만 처리 가능한 파서에게는 너무 지저분했지만, 이 보다 훨씬 단순한 프로그래밍 언어의 인공 문법에는 완벽하게 잘 맞았다
    - 그러나 이러한 단순한 문법조차 잘못 사용하는 경우가 허다해 구문 에러(syntax error)를 처리하는 임무까지 수행한다

3. 정적 분석

- 처음 두 단계는 언어들의 모든 구현체가 비슷하며, 여기서부터 언어의 개성이 드러난다
- 언어가 첫 번째 수행하는 분석 작업은 바인딩(binding), 레졸루션(resolution)이다
  - 식별자(identifier)마다 이름이 정의된 곳을 찾아 이 둘을 연결 짓는 행위다
  - scope가 아주 중요한 역할을 한다
- 정적 타입 언어(statically typed language, Java/Rust/C++ ..)는 이 단계에서 타입 체크를 한다
  - IDE가 타입에러를 바로 뱉는건 IDE내부에서 미리 프론트엔드 단계를 수행해 검사 단계를 빠르게 수행하고 있는 것이다
- 분석을 한 결과를 구문트리 자체의 속성(attribute)에 바로 저장한다, 속성은 파싱 중 초기화되지 않지만 나중에 채워지는 노드의 추가필드이다
  - 혹은 lookup table(조회 테이블)에 저장할 수도 있다
    - 이 테이블의 키는 식별자(변수 및 선언의 이름)이기에 심볼 테이블이라고도 하며, 키마다 연결된 값을 꺼내보면 식별자가 무엇을 참조하는지 알 수 있다
  - 가장 강력한 기록 도구는 시맨틱이 더욱 직접적으로 표현된 전혀 새로운 자료 구조로 트리를 변환하는 것이다
- 이 곳까지 프론트엔드에 해당한다
- 이전 컴파일러가 간단할떄는 프론트엔드/백엔드만 나뉘었지만 현재의 컴파일러는 복잡해져 중간 단계인 middle end라는 단계가 추가되었다

### 언어(컴파일러)의 중간 표현 (middle end)

1. 중간 표현
- 중간에서 소스/타깃 포맷 어느 쪽에도 엮이지 않는 중간 표현(IR, Intermediate Representation) 형태로 만드는 것이다
  - 양쪽 언어 사이의 징검다리이다
- IR은 여러 소스 언어를 타깃 플랫폼을 지원하기 위한 방법이다
  - 프론트엔드가 공통 IR을 사용해 타겟 아키텍처로 변환을 쉽게 만들어, 효율성의 증대와 역할의 분리를 만든다
  - GCC(GNU Compiler Collection)/LLVM(Low-Level Virtual Machine, 현재는 LLVM 자체를 의미로 사용)/ByteCode가 대표적인 컴파일러 인프라이다(GCC의 GIMPLE, LLVM의 LLVM IR, 그리고 Java의 ByteCode가 대표적인 IR이다)
  - 즉, 현대 컴파일러는 어셈블리적 최적화는 IR에게 맡기고 프론트엔드를 통한 고수준의 구현에 집중해 생산성과 논리성을 올린다
- IR은 "문법은 어셈블리어처럼 생겼는데, 하드웨어의 제약(레지스터 개수, 메모리 주소 등)은 받지 않는 아주 자유로운 어셈블리어이다
  - 이렇게 전달 받은 IR을 내부적으로 다양한 최적화 알고리즘을 사용해 실제 하드웨어 레지스터/메모리에 할당해서 사용하는 것이 바로 백엔드이다
2. 최적화
- 사용자 프로그램의 의미를 파악하면(프론트엔드), 시맨틱은 같지만 더 효율적으로 구현한 다른 프로그램으로 자유로이 갈아 끼울 수 있다
  - 즉, 프로그램을 최적화(optimize)할 수 있다(constant propagation, common subexpression elimination, loop invariant code motion, global value numbering, strength reduction, scalar replacement of aggregates, dead code elimination, loop unrolling)
- 하지만 성공한 언어들은 컴파일 타임 최적화를 하지 않는다(lua, cpython 등)
  - 비교적 최적화가 덜 된 코드를 생성해 주로 런타임에 성능을 높이는데 초점을 둔다

### 언어(컴파일러)의 백엔드

1. 코드 생성
- 두가지 명령어 생성으로 나뉜다
  1. 실제 CPU 명령어 생성
    - 빠르지만, 코드를 생성하는 작업이 매우 많다
    - 이식성(portability)이 없다(x86은 x86, ARM은 ARM)
  2. Virtual CPU 명령어 생성
    - 이식성이 있다(과거 컴퓨터 아키텍쳐가 매우 많던 시대에는 매우 중요한 사항이었다)
    - bytecode라고 불린다(명령어 하나당 1byte)
    - bytecode로 만들게되면 이를 해석할 수 있는 컴퓨터 아키텍처는 이 세상에 없기 때문에 기계어로 번역해야한다(번역하는 방법은 아래 두가지 방법만이 존재한다)
      - bytecode를 해당 머신의 네이티브 코드로 만드는 미니 컴파일러를 타깃 아키텍처마다 만드는 것이다(bytecode를 IR로 사용, C/C++/Rust, 정적 컴파일 / AOT(Ahead-Of-Time Compilation))
      - 런타임에 가상의 아키텍처를 지원하는 가상의 칩을 에뮬레이트(흉내)하는 프로그램, 즉 가상머신(VM, Virtual Machine)을 만드는 것이다(Java, Python, C#, GC필요한 언어, 인터프리터 방식/JIT 컴파일러 도입으로 성능이슈 해결)
        - VM에서 바이트 코드를 실행하는 것은 네이티브 코드로 번역하는 것보다 느리다
        - 명령어를 하나하나 실행할 때마다 런타임에서 시뮬레이션을 해야하기 떄문이다
        - 하지만 이에 비해 얻는 단순성과 이식성이 매우 크다
        - 즉, C로 VM을 구현하면 C 컴파일러가 있는 모든 플랫폼에서 해당 언어를 실행할 수 있다

### 런타임

- 기계어로 컴파일 되었다면, 운영 체제에게 실행파일의 로드를 맡기면 된다
- 바이트코드로 컴파일 했다면, VM을 가동 후 프로그램을 로드하면 된다

## 컴파일러의 종류

1. 싱글 패스 컴파일러
- 파싱, 분석, 코드 생성을 인터러브(inteleave, 끼워맞춤)해서 구문 트리나 IR을 할당하지 않고 바로 파서에서 출력코드를 생성하는 단순한 컴파일러가 싱글 패스 컴파일러(single-pass compiler)이다
- 언어 구조상 프로그램에 관한 글로벌 정보를 보고나할 중간 자료구조가 없고 이전에 파싱한 코드를 다시 방문하지도 않는다
  - 즉, 어떤 표현식을 보자마자 올바르게 컴파일할 수 있을 정도만 알면 된다
- Pascal, C가 이렇게 디자인된 언어이다
  - 이 시기에는 메모리가 귀해서 컴파일러는 전체 프로그램은 고사하고 소스 파일 전체를 메모리에 담기도 빠듯했다

2. 트리 탐색 인터프리터(tree-walk interpreter)

- 코드를 AST로 파싱한 후, 바로 실행을 한다
- 인터프리터는 구문 트리를 한 번에 하나의 분기와 리프 순회하면서 각 노드를 평가한다
- 이 구현은 매우 느리기에, 학교 프로젝트와 미니 언어에서 사용된다
- 제이록스가 트리 탐색 인터프리터이다