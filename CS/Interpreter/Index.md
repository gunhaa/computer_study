# 인터프리터와 컴파일러

## 언어(컴파일러)의 구성요소

> `var average = (min + max)/2;`의 구성을 처음부터 끝까지 분석해보면..

- 컴파일러의 구조는 아래 단계로 나뉜다
  - 프론트엔드 (Front-end): 소스 코드(C++, Java 등)를 읽어서 문법 검사를 하고 초기 IR(중간 표현, Intermediate Representation)을 만들어낸다
  - 미들엔드 (Middle-end): 프론트엔드가 넘겨준 IR을 분석하고 최적화(Optimization)한다, 코드를 더 빠르게, 혹은 더 작게 만든다. (예: 안 쓰는 변수 삭제, 반복문 계산 줄이기)
  - 백엔드 (Back-end): 최적화된 IR을 실제 CPU가 이해하는 기계어(Machine Code)나 어셈블리어로 바꾼다. (x86, ARM 등)
- 컴파일러는 각 단계의 작업이 다음 단계를 구현하기 쉽게 만드는 방향으로 사용자 코드를 나타내는, 일종의 데이터를 구성하는 파이프라인 이다
- 프론트엔드는 프로그램이 작성된 소스언어에 따라 달라지는 반면, 백엔드는 프로그램이 최종 실행될 타깃 아키텍처에 깊이 연관되어 있다

### 언어(컴파일러)의 프론트엔드

> 코드를 읽고 문법이 맞는지, 타입이 맞는지 분석하는 단계

1. 스캐닝(scanning) 혹은 lexing(lexical analysis, 어휘 분석)
  - 스캐너(or lexer)는 문자(character)의 선형 스트림을 받아 '단어'에 가까운 chunk들로 묶는다
  - 프로그래밍 언어에서는 이런 단어를 token이라고 한다
  - 어떤 토큰은 `나,` 처럼 단일 문자 구성된 경우도 있고, 숫자(123), 문자열 리터럴("hi"), 식별자(identifer, min)처럼 여러 문자로 이루어진 토큰도 있다
  - 소스 파일에는 아무 의미 없는 문자도 있다. 공백 문자(whitespace)는 대개 중요하지 않다
  - 주석은 정의에 따라 무시된다
  - 스캐너는 이런 토큰을 버리고 의미 있는 토큰으로 정리한다

2. 파싱(parsing, 구문 분석)
  - 구문에 문법을 모아 더 큰 표현식과 문장을 구성하는 능력이다
  - 파서는 flat한 일련의 token을 받아 문법 특유의 중첩된 성질을 반영하는 트리 구조로 만든다
    - 이 트리는 원시 구문 구조에 얼마나 가까운지에 따라 파스 트리(parse tree) 또는 추상 구문 트리(AST, Abstract Syntax Tree)라는 상이한 두 가지 이름으로 불린다
  - AI 분야와 큰 연관이 있으며, 요즘 프로그래밍 언어의 파싱 기법은 인간과 대화가 가능한 컴퓨터를 연구하던 AI과학자들이 인간의 언어를 파싱하려고 만든 것이다
    - 인간의 언어는 엄격히 정해진 문법만 처리 가능한 파서에게는 너무 지저분했지만, 이 보다 훨씬 단순한 프로그래밍 언어의 인공 문법에는 완벽하게 잘 맞았다
    - 그러나 이러한 단순한 문법조차 잘못 사용하는 경우가 허다해 구문 에러(syntax error)를 처리하는 임무까지 수행한다

3. 정적 분석

- 처음 두 단계는 언어들의 모든 구현체가 비슷하며, 여기서부터 언어의 개성이 드러난다
- 언어가 첫 번째 수행하는 분석 작업은 바인딩(binding), 레졸루션(resolution)이다
  - 식별자(identifier)마다 이름이 정의된 곳을 찾아 이 둘을 연결 짓는 행위다
  - scope가 아주 중요한 역할을 한다
- 정적 타입 언어(statically typed language, Java/Rust/C++ ..)는 이 단계에서 타입 체크를 한다
  - IDE가 타입에러를 바로 뱉는건 IDE내부에서 미리 프론트엔드 단계를 수행해 검사 단계를 빠르게 수행하고 있는 것이다
- 분석을 한 결과를 구문트리 자체의 속성(attribute)에 바로 저장한다, 속성은 파싱 중 초기화되지 않지만 나중에 채워지는 노드의 추가필드이다
  - 혹은 lookup table(조회 테이블)에 저장할 수도 있다
    - 이 테이블의 키는 식별자(변수 및 선언의 이름)이기에 심볼 테이블이라고도 하며, 키마다 연결된 값을 꺼내보면 식별자가 무엇을 참조하는지 알 수 있다
  - 가장 강력한 기록 도구는 시맨틱이 더욱 직접적으로 표현된 전혀 새로운 자료 구조로 트리를 변환하는 것이다
- 이 곳까지 프론트엔드에 해당한다
- 이전 컴파일러가 간단할떄는 프론트엔드/백엔드만 나뉘었지만 현재의 컴파일러는 복잡해져 중간 단계인 middle end라는 단계가 추가되었다

### 언어(컴파일러)의 중간 표현 (middle end)

1. 중간 표현
- 중간에서 소스/타깃 포맷 어느 쪽에도 엮이지 않는 중간 표현(IR, Intermediate Representation) 형태로 만드는 것이다
  - 양쪽 언어 사이의 징검다리이다
- IR은 여러 소스 언어를 타깃 플랫폼을 지원하기 위한 방법이다
  - 프론트엔드가 공통 IR을 사용해 타겟 아키텍처로 변환을 쉽게 만들어, 효율성의 증대와 역할의 분리를 만든다
  - GCC(GNU Compiler Collection)/LLVM(Low-Level Virtual Machine, 현재는 LLVM 자체를 의미로 사용)/ByteCode가 대표적인 컴파일러 인프라이다(GCC의 GIMPLE, LLVM의 LLVM IR, 그리고 Java의 ByteCode가 대표적인 IR이다)
  - 즉, 현대 컴파일러는 어셈블리적 최적화는 IR에게 맡기고 프론트엔드를 통한 고수준의 구현에 집중해 생산성과 논리성을 올린다
- IR은 "문법은 어셈블리어처럼 생겼는데, 하드웨어의 제약(레지스터 개수, 메모리 주소 등)은 받지 않는 아주 자유로운 어셈블리어이다
  - 이렇게 전달 받은 IR을 내부적으로 다양한 최적화 알고리즘을 사용해 실제 하드웨어 레지스터/메모리에 할당해서 사용하는 것이 바로 백엔드이다
2. 최적화
- 사용자 프로그램의 의미를 파악하면(프론트엔드), 시맨틱은 같지만 더 효율적으로 구현한 다른 프로그램으로 자유로이 갈아 끼울 수 있다
  - 즉, 프로그램을 최적화(optimize)할 수 있다(constant propagation, common subexpression elimination, loop invariant code motion, global value numbering, strength reduction, scalar replacement of aggregates, dead code elimination, loop unrolling)
- 하지만 성공한 언어들은 컴파일 타임 최적화를 하지 않는다(lua, cpython 등)
  - 비교적 최적화가 덜 된 코드를 생성해 주로 런타임에 성능을 높이는데 초점을 둔다

### 언어(컴파일러)의 백엔드

1. 코드 생성
- 두가지 명령어 생성으로 나뉜다
  1. 실제 CPU 명령어 생성
    - 빠르지만, 코드를 생성하는 작업이 매우 많다
    - 이식성(portability)이 없다(x86은 x86, ARM은 ARM)
  2. Virtual CPU 명령어 생성
    - 이식성이 있다(과거 컴퓨터 아키텍쳐가 매우 많던 시대에는 매우 중요한 사항이었다)
    - bytecode라고 불린다(명령어 하나당 1byte)
    - bytecode로 만들게되면 이를 해석할 수 있는 컴퓨터 아키텍처는 이 세상에 없기 때문에 기계어로 번역해야한다(번역하는 방법은 아래 두가지 방법만이 존재한다)
      - bytecode를 해당 머신의 네이티브 코드로 만드는 미니 컴파일러를 타깃 아키텍처마다 만드는 것이다(bytecode를 IR로 사용, C/C++/Rust, 정적 컴파일 / AOT(Ahead-Of-Time Compilation))
      - 런타임에 가상의 아키텍처를 지원하는 가상의 칩을 에뮬레이트(흉내)하는 프로그램, 즉 가상머신(VM, Virtual Machine)을 만드는 것이다(Java, Python, C#, GC필요한 언어, 인터프리터 방식/JIT 컴파일러 도입으로 성능이슈 해결)
        - VM에서 바이트 코드를 실행하는 것은 네이티브 코드로 번역하는 것보다 느리다
        - 명령어를 하나하나 실행할 때마다 런타임에서 시뮬레이션을 해야하기 떄문이다
        - 하지만 이에 비해 얻는 단순성과 이식성이 매우 크다
        - 즉, C로 VM을 구현하면 C 컴파일러가 있는 모든 플랫폼에서 해당 언어를 실행할 수 있다

### 런타임

- 기계어로 컴파일 되었다면, 운영 체제에게 실행파일의 로드를 맡기면 된다
- 바이트코드로 컴파일 했다면, VM을 가동 후 프로그램을 로드하면 된다

## 컴파일러의 종류

1. 싱글 패스 컴파일러
- 파싱, 분석, 코드 생성을 인터러브(inteleave, 끼워맞춤)해서 구문 트리나 IR을 할당하지 않고 바로 파서에서 출력코드를 생성하는 단순한 컴파일러가 싱글 패스 컴파일러(single-pass compiler)이다
- 언어 구조상 프로그램에 관한 글로벌 정보를 보고나할 중간 자료구조가 없고 이전에 파싱한 코드를 다시 방문하지도 않는다
  - 즉, 어떤 표현식을 보자마자 올바르게 컴파일할 수 있을 정도만 알면 된다
- Pascal, C가 이렇게 디자인된 언어이다
  - 이 시기에는 메모리가 귀해서 컴파일러는 전체 프로그램은 고사하고 소스 파일 전체를 메모리에 담기도 빠듯했다

2. 트리 탐색 인터프리터(tree-walk interpreter)

- 코드를 AST로 파싱한 후, 바로 실행을 한다
- 인터프리터는 구문 트리를 한 번에 하나의 분기와 리프 순회하면서 각 노드를 평가한다
- 이 구현은 매우 느리기에, 학교 프로젝트와 미니 언어에서 사용된다
- 제이록스가 트리 탐색 인터프리터이다

3. 트랜스파일러(transcompiler)

- 다른 언어를 마치 중간 표현인 양 취급하는 것이다
- 대표적으로 babel이 js의 version 트랜스파일러이고, typescript도 javascript의 superset으로써 javascript로 컴파일 한다

4. JIT 컴파일러

- end user의 컴퓨터가 어떤 아키텍처를 지원할지 모를 경우 사용한다
  - 여기서 모른다는 것은 개발자 시점을 의미한다, 개발자가 배포할때 타깃 아키텍처를 모른다면 x86용, ARM용으로 배포할 수 밖에 없다
  - 근데 이건 일반적인 네이티브 컴파일도 두가지 바이너리로 제공하면 똑같은거아닌가?
    - 네이티브(C/C++, Go, Rust 등): 개발자가 모든 타겟을 미리 알고 빌드(경우의수가 매우 많을 수 있음)
    - JIT/VM (Java, C# 등): 개발자는 단 하나의 바이트코드(.jar, .class)만 배포(VM은 사용자가 별도 설치)
    - 네이티브(AOT)의 딜레마: 개발자가 x86용 프로그램을 만들 때, "가장 구형 CPU"를 기준으로 만들 수밖에 없다
      - 예를 들어, 최신 인텔 CPU에는 AVX-512라는 빠른 명령어 세트가 있다. 하지만 개발자는 이걸 맘대로 못 쓴다. 이걸 썼다가는 5년 된 컴퓨터를 쓰는 사용자에게는 프로그램이 Crash가 나기 때문이다
    - JIT의 강점 (적응형 최적화): JIT은 프로그램이 실행되는 그 순간에 사용자의 CPU를 확인한다
       - "지금 돌리는 컴퓨터가 최신형이네? AVX-512 명령어 써서 2배 빠르게 돌려야지!"
       - "이 컴퓨터는 구형이네? 그럼 기본 명령어로 안전하게 돌려야지."
- 프로그램이 로드되면 그 프로그램이 실행될 컴퓨터에서 지원되는 아키텍처의 네이티브 코드로 컴파일 된다
  - 이 로직 때문에 적시 컴파일(Just-In-Time compilation)이라고 한다
  - 정교한 JIT은 프로파일링 훅을 삽입해서(profiling hook, 성능 프로파일링 수행에 필요한 메트릭을 수집하기 위해 코드 중간중간에 집어넣는 일종의 콜백함수) 어느 부분이 성능에 가장 큰 영향을 미치는지, 어떤 종루의 데이터가 이 부분을 통과해서 흘러가는지 조사한다
    - 시간이 흐르면 이런 hot spot에 최적화한 옵션을 적용하여 자동으로 재 컴파일을 수행한다
- JIT 컴파일은 동적언어를 구현하는 가장 빠른 방법이지만, 모두 JIT을 사용하지 않는다. 트레이드 오프가 있나?
  1. 시작 시간이 느리다(Startup latency, warm up): 분석(Profiling) → 최적화 → 기계어 변환이 필요하다
  2. 메모리가 많이 필요하다 (Memory Overhead): 코드 캐시(원본 소스코드 + 컴파일된 기계어 코드), 프로파일링 데이터(어디가 Hotspot인가?), JIT 컴파일러 자체가 크다
  3. 구현 난이도(Complexity): 제대로 된 최적화 JIT 컴파일러(예: V8, JVM HotSpot)를 만드는 것은 컴퓨터 공학에서 가장 어려운 작업 중 하나이며, 실행 중에 코드를 뜯어고치는 기술은 구글, 오라클, 모질라 같은 거대 기업이 수년, 수십 년간 엔지니어들을 갈아 넣어 만든 결과물이다


## 컴파일러와 인터프리터

1. compule은 소스 언어를 (보통 더 로우 레벨의)언어로 번역하는 구현 기법이다
  - 바이트코드나 기계어를 생성하는 작업이 바로 컴파일이다
  - 다른 하이레벨 언어로 트랜스파일하는 것 역시 컴파일이다
2. 어떤 언어 구현체가 "is a compiler"라고 함은, 소스코드를 다른 형식으로 번역하되 그것을 실행하지는 않는다는 뜻이다. 결과물을 가져와 실행하는 일은 사용자의 몫이다
3. "is an interpreter"라고 함은 소스 코드를 받아 즉시 실행한다는 뜻이다
- Java/Python/JS: 소스코드/바이트코드 ➡ 가상머신(VM)이나 인터프리터가 읽음 ➡ OS/CPU에게 전달
- Rust/C/C++: 기계어 바이너리 ➡ CPU가 직접 읽고 실행 (OS는 메모리에 올려주기만 함)
