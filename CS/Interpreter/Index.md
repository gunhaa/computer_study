# 인터프리터와 컴파일러

## 언어(컴파일러)의 구성요소

> `var average = (min + max)/2;`의 구성을 처음부터 끝까지 분석해보면..

- 컴파일러의 구조는 아래 단계로 나뉜다
  - 프론트엔드 (Front-end): 소스 코드(C++, Java 등)를 읽어서 문법 검사를 하고 초기 IR(중간 표현, Intermediate Representation)을 만들어낸다
  - 미들엔드 (Middle-end): 프론트엔드가 넘겨준 IR을 분석하고 최적화(Optimization)한다, 코드를 더 빠르게, 혹은 더 작게 만든다. (예: 안 쓰는 변수 삭제, 반복문 계산 줄이기)
  - 백엔드 (Back-end): 최적화된 IR을 실제 CPU가 이해하는 기계어(Machine Code)나 어셈블리어로 바꾼다. (x86, ARM 등)
- 컴파일러는 각 단계의 작업이 다음 단계를 구현하기 쉽게 만드는 방향으로 사용자 코드를 나타내는, 일종의 데이터를 구성하는 파이프라인 이다
- 프론트엔드는 프로그램이 작성된 소스언어에 따라 달라지는 반면, 백엔드는 프로그램이 최종 실행될 타깃 아키텍처에 깊이 연관되어 있다

### 언어(컴파일러)의 프론트엔드

> 코드를 읽고 문법이 맞는지, 타입이 맞는지 분석하는 단계

1. 스캐닝(scanning) 혹은 lexing(lexical analysis, 어휘 분석)
  - 스캐너(or lexer)는 문자(character)의 선형 스트림을 받아 '단어'에 가까운 chunk들로 묶는다
  - 프로그래밍 언어에서는 이런 단어를 token이라고 한다
  - 어떤 토큰은 `나,` 처럼 단일 문자 구성된 경우도 있고, 숫자(123), 문자열 리터럴("hi"), 식별자(identifer, min)처럼 여러 문자로 이루어진 토큰도 있다
  - 소스 파일에는 아무 의미 없는 문자도 있다. 공백 문자(whitespace)는 대개 중요하지 않다
  - 주석은 정의에 따라 무시된다
  - 스캐너는 이런 토큰을 버리고 의미 있는 토큰으로 정리한다

2. 파싱(parsing, 구문 분석)
  - 구문에 문법을 모아 더 큰 표현식과 문장을 구성하는 능력이다
  - 파서는 flat한 일련의 token을 받아 문법 특유의 중첩된 성질을 반영하는 트리 구조로 만든다
    - 이 트리는 원시 구문 구조에 얼마나 가까운지에 따라 파스 트리(parse tree) 또는 추상 구문 트리(AST, Abstract Syntax Tree)라는 상이한 두 가지 이름으로 불린다
  - AI 분야와 큰 연관이 있으며, 요즘 프로그래밍 언어의 파싱 기법은 인간과 대화가 가능한 컴퓨터를 연구하던 AI과학자들이 인간의 언어를 파싱하려고 만든 것이다
    - 인간의 언어는 엄격히 정해진 문법만 처리 가능한 파서에게는 너무 지저분했지만, 이 보다 훨씬 단순한 프로그래밍 언어의 인공 문법에는 완벽하게 잘 맞았다
    - 그러나 이러한 단순한 문법조차 잘못 사용하는 경우가 허다해 구문 에러(syntax error)를 처리하는 임무까지 수행한다

3. 정적 분석

- 처음 두 단계는 언어들의 모든 구현체가 비슷하며, 여기서부터 언어의 개성이 드러난다
- 언어가 첫 번째 수행하는 분석 작업은 바인딩(binding), 레졸루션(resolution)이다
  - 식별자(identifier)마다 이름이 정의된 곳을 찾아 이 둘을 연결 짓는 행위다
  - scope가 아주 중요한 역할을 한다
- 정적 타입 언어(statically typed language, Java/Rust/C++ ..)는 이 단계에서 타입 체크를 한다
  - IDE가 타입에러를 바로 뱉는건 IDE내부에서 미리 프론트엔드 단계를 수행해 검사 단계를 빠르게 수행하고 있는 것이다
- 분석을 한 결과를 구문트리 자체의 속성(attribute)에 바로 저장한다, 속성은 파싱 중 초기화되지 않지만 나중에 채워지는 노드의 추가필드이다
  - 혹은 lookup table(조회 테이블)에 저장할 수도 있다
    - 이 테이블의 키는 식별자(변수 및 선언의 이름)이기에 심볼 테이블이라고도 하며, 키마다 연결된 값을 꺼내보면 식별자가 무엇을 참조하는지 알 수 있다
  - 가장 강력한 기록 도구는 시맨틱이 더욱 직접적으로 표현된 전혀 새로운 자료 구조로 트리를 변환하는 것이다
- 이 곳까지 프론트엔드에 해당한다
- 이전 컴파일러가 간단할떄는 프론트엔드/백엔드만 나뉘었지만 현재의 컴파일러는 복잡해져 중간 단계인 middle end라는 단계가 추가되었다

### 중간 표현 (middle end)

- 중간에서 소스/타깃 포맷 어느 쪽에도 엮이지 않는 중간 표현(IR, Intermediate Representation) 형태로 만드는 것이다
  - 양쪽 언어 사이의 징검다리이다
- IR은 여러 소스 언어를 타깃 플랫폼을 지원하기 위한 방법이다
  - 프론트엔드가 공통 IR을 사용해 타겟 아키텍처로 변환을 쉽게 만들어, 효율성의 증대와 역할의 분리를 만든다
  - GCC(GNU Compiler Collection)/LLVM(Low-Level Virtual Machine, 현재는 LLVM 자체를 의미로 사용)/ByteCode가 대표적인 컴파일러 인프라이다(GCC의 GIMPLE, LLVM의 LLVM IR, 그리고 Java의 ByteCode가 대표적인 IR이다)
  - 즉, 현대 컴파일러는 어셈블리적 최적화는 IR에게 맡기고 프론트엔드를 통한 고수준의 구현에 집중해 생산성과 논리성을 올린다
- IR은 "문법은 어셈블리어처럼 생겼는데, 하드웨어의 제약(레지스터 개수, 메모리 주소 등)은 받지 않는 아주 자유로운 어셈블리어이다
  - 이렇게 전달 받은 IR을 내부적으로 다양한 최적화 알고리즘을 사용해 실제 하드웨어 레지스터/메모리에 할당해서 사용하는 것이 바로 백엔드이다